[40-크기가 작은 부분문자열 코드](../codes/40크기가_작은_부분문자열.js)  

### 문제 설명

숫자로 이루어진 문자열 `t`와 `p`가 주어질 때, `t`에서 `p`와 길이가 같은 부분문자열 중에서, 이 부분문자열이 나타내는 수가 `p`가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return하는 함수 solution을 완성하세요.

예를 들어, `t`="3141592"이고 `p`="271" 인 경우, `t`의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다. 이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다.

### 제한사항

- 1 ≤ `p`의 길이 ≤ 18
- `p`의 길이 ≤ `t`의 길이 ≤ 10,000
- `t`와 `p`는 숫자로만 이루어진 문자열이며, 0으로 시작하지 않습니다.

### 입출력 예

| t | p | result |
| --- | --- | --- |
| "3141592" | "271" | 2 |
| "500220839878" | "7" | 8 |
| "10203" | "15" | 3 |

### 입출력 예 설명

입출력 예 #1

본문과 같습니다.

입출력 예 #2

`p`의 길이가 1이므로 `t`의 부분문자열은 "5", "0", 0", "2", "2", "0", "8", "3", "9", "8", "7", "8"이며 이중 7보다 작거나 같은 숫자는 "5", "0", "0", "2", "2", "0", "3", "7" 이렇게 8개가 있습니다.

입출력 예 #3

`p`의 길이가 2이므로 `t`의 부분문자열은 "10", "02", "20", "03"이며, 이중 15보다 작거나 같은 숫자는 "10", "02", "03" 이렇게 3개입니다. "02"와 "03"은 각각 2, 3에 해당한다는 점에 주의하세요

# 첫풀이  
```jsx
function solution(t, p) {
    let count = 0;

    for(let i = 0; i <= t.length - p.length; i++) {
        // const str = t.substr(i, p.length);
        // const str = t.substring(i, i + p.length);
        const str = t.slice(i, i + p.length);
        // console.log(str);
        if(str <= p) {
            count++;
        }
    }

    return count;
}
```
> 첫 풀이  
> 반복문을  `t`의 부분 문자열을 추출할 수 있는 범위  `t.length - p.length`까지 반복  
> `substr()`, `substring()`, `slice()` 함수중 하나를 이용하여 문자열의 일부분을 추출  
> 추출한 `str`을 p와 비교, p보다 작거나 같은 경우 `count`변수 증가. 
> 문자열이 숫자로 이루어져 있을 경우 숫자 크기를 비교함  
> `count` 리턴  
>
### `substr`, `substring`, `slice` 차이점  
-  `substr(start, length)`: `start` 인덱스부터 시작하여 `length` 길이만큼의 부분 문자열을 반환합니다. `start`는 0부터 시작하는 인덱스이고, `length`는 선택적 매개변수입니다. `length`가 생략되면 `start`부터 문자열의 끝까지의 부분 문자열을 반환합니다. 음수 값이 주어지면 문자열 끝에서부터 역으로 카운트합니다.  
  
-  `substring(start, end)`: `start` 인덱스부터 `end` 인덱스 이전까지의 부분 문자열을 반환합니다. `start`와 `end`는 0부터 시작하는 인덱스입니다. `start` 인덱스부터 `end` 이전까지의 부분 문자열을 반환하며, `end` 인덱스는 포함되지 않습니다. `end`는 선택적 매개변수이며 생략하면 문자열의 끝까지를 의미합니다. `start`와 `end`를 뒤바꿔도 동작하며, `start`가 `end`보다 클 경우 두 값이 교환됩니다.  
  
-  `slice(start, end)`: `start` 인덱스부터 `end` 인덱스 이전까지의 부분 문자열을 반환합니다. `substring`과 마찬가지로 `start`와 `end`는 0부터 시작하는 인덱스입니다. `substring`과 달리 `slice`는 음수 인덱스를 허용합니다. 음수 인덱스는 문자열의 끝에서부터 역으로 카운트합니다. `start`와 `end`는 모두 선택적 매개변수이며, 생략하면 문자열의 처음부터 끝까지를 의미합니다. `substring`과 마찬가지로 `start`가 `end`보다 클 경우 두 값이 교환됩니다.  

이 세 가지 메서드는 모두 원래 문자열을 변경하지 않고 새로운 부분 문자열을 반환합니다.  