[45-가장 가까운 같은 글자](../codes/45가장_가까운_같은_글자.js)   

### **문제 설명**

문자열 `s`가 주어졌을 때, `s`의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다.

예를 들어, `s`="banana"라고 할 때,  각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.

- b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.
- n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.
- a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.

따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.

문자열 `s`이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.

---

### 제한사항

- 1 ≤ `s`의 길이 ≤ 10,000
    - `s`은 영어 소문자로만 이루어져 있습니다.

---

### 입출력 예

---

### 입출력 예 설명

입출력 예 #1

지문과 같습니다.

입출력 예 #2

설명 생략

# 첫풀이  
```jsx
function solution(s) {
  const answer = [];
  const arr = [];

  for (let i = 0; i < s.length; i++) {
      // arr 배열에 현재 글자 s[i]가 포함되어 있는 경우(이전에 이미 나타난 글자인 경우)
      if(arr.includes(s[i])) {
          // console.log("차이", arr.length - arr.lastIndexOf(s[i]));
          // arr 배열에서 현재 글자 s[i]의 마지막 인덱스를 찾아서 전체 길이에서 빼서 현재 위치와 가장 가까운 같은 글자와의 거리를 구함
          answer.push(arr.length - arr.lastIndexOf(s[i]));
          arr.push(s[i]);
          // console.log("포함o:", answer, arr);
      } else { // arr 배열에 현재 글자 s[i]가 포함되어 있지 않은 경우(이전에 나타나지 않은 글자인 경우)
          answer.push(-1);
          arr.push(s[i]);
          // console.log("포함x:", answer, arr);
      }
  }
  
  return answer;
}
```
> 첫 풀이  
> `answer`는 결과, `arr`은 이전에 나타난 글자들을 저장하는 검사용  
> 조건문의 조건으로 `arr` 배열에 현재 글자 `s[i]`가 포함되어 있는 경우(이전에 이미 나타난 글자인 경우)  
> `arr` 배열에서 현재 글자 `s[i]의 마지막 인덱스`를 찾아서 `전체 길이`에서 빼서 현재 위치와 가장 가까운 같은 글자와의 거리를 구하고 `answer` 배열에 추가  
> 현재 글자 `s[i]`를 `arr` 배열에 추가  
> `arr` 배열에 현재 글자 `s[i]`가 포함되어 있지 않은 경우(이전에 나타나지 않은 글자인 경우)  
> -1을 `answer` 배열에 추가  
> 현재 글자 `s[i]`를 arr 배열에 추가  
> 반복후 `answer` 배열 리턴  

# `map()`, `slice()` 활용
```jsx
function solution(s) {
    const answer = [];
    [...s].map((char, i) => {
        const count = s.slice(0, i).lastIndexOf(char);
        // console.log(count);
        answer.push(count === -1 ? -1 : i - count)
        // console.log(answer);
    });
    
    return answer;
}
```
> `answer`는 결과  
> spread 문법으로 `s` 문자열을 배열로 변환,  
> `map()` 활용. `char: 현재 문자`,  `i: 해당 문자의 인덱스`  
> `slice()` 활용. `s`에서 인덱스 0부터 i 이전까지의 부분 문자열을 추출  
> `lastIndexOf()` 활용. 부분 문자열에서 현재 문자 `char`의 가장 마지막 인덱스를 찾기  
> 만약 가장 마지막 인덱스가 -1이라면 -1을 `answer` 배열에 추가  
> 가장 마지막 인덱스가 -1이 아닌 경우  
> 현재 인덱스 `i`에서 이전에 나타난 같은 글자의 인덱스 `count`를 뺀 값을 구해서, 현재 위치와 가장 가까운 같은 글자와의 거리를 구함  
> 이 거리를 `answer` 배열에 추가  
> 반복후 `answer` 배열 리턴  